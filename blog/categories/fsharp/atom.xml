<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: fsharp | Tamizh's Thoughts]]></title>
  <link href="http://tamizhvendan.github.com/blog/categories/fsharp/atom.xml" rel="self"/>
  <link href="http://tamizhvendan.github.com/"/>
  <updated>2013-08-08T16:24:18+05:30</updated>
  <id>http://tamizhvendan.github.com/</id>
  <author>
    <name><![CDATA[Tamizhvendan S]]></name>
    <email><![CDATA[tamizh88@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[If your fsharp code compiles it usually works]]></title>
    <link href="http://tamizhvendan.github.com/blog/2013/08/08/if-your-fsharp-code-compiles-it-usually-works/"/>
    <updated>2013-08-08T11:39:00+05:30</updated>
    <id>http://tamizhvendan.github.com/blog/2013/08/08/if-your-fsharp-code-compiles-it-usually-works</id>
    <content type="html"><![CDATA[<div class="post">

  <p>
    When I first started learning fsharp, one of the astounding fact that hit my mind was <em>"If the code compiles it usually works!"</em> For a guy who is coming from c# and java Programming background it was bit weird! After delving deep into f# I have found it very useful and inspired by its awesomeness. In this blog-post I'll be covering some of my experiences that I come across while learning this great feature!  
  </p>

  <h3>Fever Diagnosis Program</h3>
  <p>
    Let us consider a simple fever diagnosis program. If your temperature is greater than 37.5 Celsius or 99.0 Fahrenheit then you are suffering from fever else you are all right.  
  </p>

  <h3>Defining Temperature Types</h3>
  <p>One of the cool feature that I like about f# is its less verbosity. You can do lot of magic things with less lines of code! Consider our fever diagnosis program, A temperature can be either in Celsius or in Fahrenheit. Here is the equivalent type defined in f#</p>

  {% codeblock lang:fsharp %}
type Temperature = 
  | Celsius of double
  | Fahrenheit of double  {% endcodeblock %}

  <p>Just 3 lines of code!</p>
  <p>The type Temperature has been defined as a <a href="http://en.wikibooks.org/wiki/F_Sharp_Programming/Discriminated_Unions">discriminated union.</a> In brief, Discriminated union represent data that can take on one of a few different types of results.</p> <p>Also in this 3 lines we have described the strongly typed alias for temperature in both Celsius and in Fahrenheit. With this code in place if you want to describe a temperature in Celsius or in Fahrenheit all you need to use the following syntax</p>

  {% codeblock lang:fsharp %}
let tempInCelsius = Celsius 10.8
let tempInFahernheit = Fahrenheit 10.6 {% endcodeblock %}

  <p>By defining strongly typed cases like this we can make our code cleaner and preventing ourselves from various logic errors that we usually do when we interpret the values of these types. Though we can achieve the same in c# by the following code, it is very elegant to do in f# </p>

  {% codeblock lang:csharp %}
public abstract class Temperature 
{
  public double Value { get; private set; }

  protected Temperature(double value) 
  {
    Value = value;
  }
}

public class Celsius : Temperature
{
  public Celsius (double value) : base(value)
  {

  }
}

public class Fahrenheit : Temperature
{
  public Fahrenheit (double value) : base(value)
  {
    
  }
} 

public class Program 
{
  public static void Main() 
  {
    Temperature tempInCelsius = new Celsius(10.8);
    Temperature tempInFahernheit = new Fahrenheit(10.6);
  }  
}{% endcodeblock %}

<p>34 lines of code to achieve the same!!</p>

<h3>Let's diagnosis fever</h3>
<p>With the types for the two representation of temperature in place, our next step is to check the values and find out whether the concerned person is having fever or not. You can do this in f# by using <a href="http://en.wikibooks.org/wiki/F_Sharp_Programming/Pattern_Matching_Basics">pattern matching</a></p>
{% codeblock lang:fsharp %}
let hasFever temperature =
  match temperature with 
  | Celsius value -> (value > 37.5)
  | Fahrenheit value -> (value > 99.0) {% endcodeblock %}

<p>f# automatically takes care of decomposing our data into appropriate data structure and all we need to concentrate on our business logic. For a beginner the syntax might look intimidating at first sight but if we use it quite some time you will fell in love with f#</p> 

<h4>How can I call this function?</h4>
{% codeblock lang:fsharp %}
hasFever (Celsius 10.5)
hasFever (Fahrenheit 22.5){% endcodeblock %}

<p>Based on the type we are passing in the hasFever function, the corresponding pattern will be matched then the value is decomposed and verified with their respective numbers. Code is prettier, isn't it ?</p>

<h3>What's the big deal in it?</h3>
<p>You might think apart from reducing the lines of code what else f# adds ?. Great! I was exactly like you when I first come across it. Later I've found out it how it can help us to save some hairs ;-) </p>

<p>Let us assume that we forget to handle Fahrenheit in hasFever function</p>
{% codeblock lang:fsharp %}
let hasFever temperature =
  match temperature with 
  | Celsius value -> (value > 37.5){% endcodeblock %}
<p>Typically in C# if we missed to handle one of the cases like this we won't be getting any compiler error and It'd crash the application in the runtime. But in f#, the above code would result in following compiler error</p>
<pre>warning FS0025: Incomplete pattern matches on this expression, For example, the value 'Fahrenheit (_)' may indicate a case not covered by the pattern(s)</pre>
<p>So, if you make any logical error like this is your f# code, compiler will show compile time errors and prevents you from building buggy code!</p>

<h3>Summary</h3>
<p>If you follow the idioms of f#, it will let you write a better code and even if do some logical error the compiler will come as a rescue!. You can check the source code live in <a href="http://www.tryfsharp.org/create/tamizhvendan/fever_diagnosis.fsx">tryfsharp</a> </p>
</div>

]]></content>
  </entry>
  
</feed>
